# vCluster API: Golang Conversion

## Directory Structure

```
vcluster-api/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── auth/
│   │   └── authenticator.go
│   ├── config/
│   │   └── config.go
│   ├── handlers/
│   │   ├── clusters.go
│   │   ├── webhooks.go
│   │   └── dynamic.go
│   ├── models/
│   │   └── models.go
│   └── services/
│       ├── cluster_service.go
│       └── pruning_service.go
├── k8s/
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── ingress.yaml
│   └── rbac.yaml
├── config/
│   ├── config.yaml
│   └── endpoints.yaml
├── Dockerfile
└── go.mod
```

## Main Application (cmd/server/main.go)

```go
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"

	"vcluster-api/internal/config"
	"vcluster-api/internal/handlers"
	"vcluster-api/internal/services"
)

func main() {
	// Configure logging
	log.SetOutput(os.Stdout)
	log.Println("Starting vCluster Manager API")

	// Load configuration
	cfg := config.GetConfig()

	// Set Gin mode based on debug setting
	if !cfg.Server.Debug {
		gin.SetMode(gin.ReleaseMode)
	}

	// Create router with default middleware
	r := gin.Default()

	// Configure CORS
	r.Use(cors.New(cors.Config{
		AllowOrigins:     cfg.Server.AllowedOrigins,
		AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Authorization", "Content-Type", "X-API-Key"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	// API routes
	api := r.Group("/api/v1")
	
	// Register cluster routes
	handlers.RegisterClusterRoutes(api)
	
	// Register webhook routes
	handlers.RegisterWebhookRoutes(api)
	
	// Include dynamic endpoints if enabled
	if cfg.DynamicEndpoints.Enabled {
		handlers.RegisterDynamicRoutes(r)
		log.Println("Dynamic endpoints enabled")
	}

	// Health check endpoint
	r.GET("/api/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "healthy"})
	})

	// Setup pruning service
	pruningInterval := cfg.VCluster.PruningIntervalHours
	services.SetupPruningScheduler(pruningInterval)

	// Start the server
	srv := &http.Server{
		Addr:    fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port),
		Handler: r,
	}

	// Start server in a goroutine
	go func() {
		log.Printf("API server listening on %s:%d\n", cfg.Server.Host, cfg.Server.Port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Failed to start server: %v", err)
		}
	}()

	// Wait for interrupt signal to gracefully shut down the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Println("Shutting down vCluster Manager API")

	// Set shutdown timeout
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Shutdown the server
	if err := srv.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v", err)
	}

	log.Println("Server exited gracefully")
}
```

## Configuration System (internal/config/config.go)

```go
package config

import (
	"log"
	"os"
	"strconv"
	"strings"
	"sync"

	"gopkg.in/yaml.v2"
)

// AppConfig represents the application configuration
type AppConfig struct {
	Server struct {
		Host           string   `yaml:"host"`
		Port           int      `yaml:"port"`
		Debug          bool     `yaml:"debug"`
		AllowedOrigins []string `yaml:"allowed_origins"`
	} `yaml:"server"`
	Auth struct {
		JWT struct {
			SecretKey         string `yaml:"secret_key"`
			Algorithm         string `yaml:"algorithm"`
			TokenExpireMinutes int    `yaml:"token_expire_minutes"`
		} `yaml:"jwt"`
		APIKeys map[string]string `yaml:"api_keys"`
	} `yaml:"auth"`
	Webhooks struct {
		GitHub struct {
			Enabled bool   `yaml:"enabled"`
			Secret  string `yaml:"secret"`
		} `yaml:"github"`
		Bitbucket struct {
			Enabled bool   `yaml:"enabled"`
			Secret  string `yaml:"secret"`
		} `yaml:"bitbucket"`
	} `yaml:"webhooks"`
	VCluster struct {
		DefaultK8sVersion     string `yaml:"default_k8s_version"`
		DefaultTTLHours       int    `yaml:"default_ttl_hours"`
		PruningIntervalHours  int    `yaml:"pruning_interval_hours"`
		NamespacePrefix       string `yaml:"namespace_prefix"`
	} `yaml:"vcluster"`
	DynamicEndpoints struct {
		Enabled    bool   `yaml:"enabled"`
		ConfigPath string `yaml:"config_path"`
	} `yaml:"dynamic_endpoints"`
}

var (
	instance *AppConfig
	once     sync.Once
)

// GetConfig returns a singleton instance of the application configuration
func GetConfig() *AppConfig {
	once.Do(func() {
		instance = &AppConfig{}
		
		// Set default values
		instance.Server.Host = "0.0.0.0"
		instance.Server.Port = 8000
		instance.Server.Debug = false
		instance.Auth.JWT.Algorithm = "HS256"
		instance.Auth.JWT.TokenExpireMinutes = 30
		instance.Webhooks.GitHub.Enabled = true
		instance.Webhooks.Bitbucket.Enabled = true
		instance.VCluster.DefaultK8sVersion = "1.25"
		instance.VCluster.DefaultTTLHours = 24
		instance.VCluster.PruningIntervalHours = 1
		instance.DynamicEndpoints.Enabled = true
		instance.DynamicEndpoints.ConfigPath = "config/endpoints.yaml"
		
		// Try to load config from file
		configPath := os.Getenv("CONFIG_PATH")
		if configPath == "" {
			configPath = "config/config.yaml"
		}
		
		loadConfigFromFile(instance, configPath)
		
		// Override with environment variables
		loadFromEnv(instance)
		
		// Validate critical configuration
		if instance.Auth.JWT.SecretKey == "" {
			log.Println("Warning: JWT secret key not configured - this is a security risk for production!")
		}
	})
	
	return instance
}

// loadConfigFromFile loads configuration from a YAML file
func loadConfigFromFile(cfg *AppConfig, path string) {
	data, err := os.ReadFile(path)
	if err != nil {
		log.Printf("Config file %s not found, using defaults and environment variables: %v", path, err)
		return
	}
	
	err = yaml.Unmarshal(data, cfg)
	if err != nil {
		log.Printf("Error parsing config file: %v", err)
		return
	}
	
	log.Printf("Loaded configuration from %s", path)
}

// loadFromEnv loads configuration from environment variables
func loadFromEnv(cfg *AppConfig) {
	// JWT settings
	if val := os.Getenv("JWT_SECRET_KEY"); val != "" {
		cfg.Auth.JWT.SecretKey = val
	}
	if val := os.Getenv("JWT_ALGORITHM"); val != "" {
		cfg.Auth.JWT.Algorithm = val
	}
	if val := os.Getenv("ACCESS_TOKEN_EXPIRE_MINUTES"); val != "" {
		if minutes, err := strconv.Atoi(val); err == nil {
			cfg.Auth.JWT.TokenExpireMinutes = minutes
		}
	}
	
	// Webhook secrets
	if val := os.Getenv("GITHUB_WEBHOOK_SECRET"); val != "" {
		cfg.Webhooks.GitHub.Secret = val
	}
	if val := os.Getenv("BITBUCKET_WEBHOOK_SECRET"); val != "" {
		cfg.Webhooks.Bitbucket.Secret = val
	}
	
	// Server settings
	if val := os.Getenv("SERVER_HOST"); val != "" {
		cfg.Server.Host = val
	}
	if val := os.Getenv("SERVER_PORT"); val != "" {
		if port, err := strconv.Atoi(val); err == nil {
			cfg.Server.Port = port
		}
	}
	if val := os.Getenv("DEBUG"); val != "" {
		cfg.Server.Debug = val == "true" || val == "1" || val == "yes"
	}
	if val := os.Getenv("ALLOWED_ORIGINS"); val != "" {
		cfg.Server.AllowedOrigins = strings.Split(val, ",")
	}
	
	// vCluster settings
	if val := os.Getenv("DEFAULT_K8S_VERSION"); val != "" {
		cfg.VCluster.DefaultK8sVersion = val
	}
	if val := os.Getenv("DEFAULT_TTL_HOURS"); val != "" {
		if hours, err := strconv.Atoi(val); err == nil {
			cfg.VCluster.DefaultTTLHours = hours
		}
	}
	if val := os.Getenv("PRUNING_INTERVAL_HOURS"); val != "" {
		if hours, err := strconv.Atoi(val); err == nil {
			cfg.VCluster.PruningIntervalHours = hours
		}
	}
	if val := os.Getenv("NAMESPACE_PREFIX"); val != "" {
		cfg.VCluster.NamespacePrefix = val
	}
	
	// Dynamic endpoints settings
	if val := os.Getenv("DYNAMIC_ENDPOINTS"); val != "" {
		cfg.DynamicEndpoints.Enabled = val != "false" && val != "0" && val != "no"
	}
	if val := os.Getenv("ENDPOINTS_CONFIG_PATH"); val != "" {
		cfg.DynamicEndpoints.ConfigPath = val
	}
}
```

## Authentication System (internal/auth/authenticator.go)

```go
package auth

import (
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v4"
	
	"vcluster-api/internal/config"
)

// Claims is a struct that will be encoded to a JWT token
type Claims struct {
	Username string `json:"username"`
	Scope    string `json:"scope"`
	jwt.RegisteredClaims
}

// TokenResponse represents the structure of a token response
type TokenResponse struct {
	AccessToken string `json:"access_token"`
	TokenType   string `json:"token_type"`
	ExpiresIn   int    `json:"expires_in"`
}

// VerifyToken validates a JWT token from the Authorization header
func VerifyToken(c *gin.Context) (map[string]interface{}, error) {
	// Extract token from Authorization header
	authHeader := c.GetHeader("Authorization")
	if authHeader == "" {
		return nil, errors.New("authorization header is missing")
	}
	
	parts := strings.Split(authHeader, " ")
	if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" {
		return nil, errors.New("invalid authorization header format")
	}
	
	tokenString := parts[1]
	
	// Get JWT settings from config
	cfg := config.GetConfig()
	secretKey := []byte(cfg.Auth.JWT.SecretKey)
	algorithm := cfg.Auth.JWT.Algorithm
	
	// Parse and validate the token
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		// Validate the algorithm
		if token.Method.Alg() != algorithm {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return secretKey, nil
	})
	
	if err != nil {
		return nil, err
	}
	
	// Extract claims
	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		return claims, nil
	}
	
	return nil, errors.New("invalid token")
}

// VerifyAPIKey validates an API key from the X-API-Key header
func VerifyAPIKey(c *gin.Context) (map[string]interface{}, error) {
	// Extract API key from header
	apiKey := c.GetHeader("X-API-Key")
	if apiKey == "" {
		return nil, errors.New("API key header is missing")
	}
	
	// Get allowed API keys from config
	cfg := config.GetConfig()
	apiKeys := cfg.Auth.APIKeys
	
	// Find matching client for this API key
	for clientID, key := range apiKeys {
		if key == apiKey {
			return map[string]interface{}{
				"client_id": clientID,
				"scope":     "api",
			}, nil
		}
	}
	
	return nil, errors.New("invalid API key")
}

// CreateAccessToken creates a new JWT token
func CreateAccessToken(data map[string]interface{}, expireMinutes int) (string, error) {
	// Get JWT settings from config
	cfg := config.GetConfig()
	secretKey := []byte(cfg.Auth.JWT.SecretKey)
	algorithm := cfg.Auth.JWT.Algorithm
	
	if expireMinutes <= 0 {
		expireMinutes = cfg.Auth.JWT.TokenExpireMinutes
	}
	
	// Create the claims
	claims := jwt.MapClaims{
		"exp": time.Now().Add(time.Minute * time.Duration(expireMinutes)).Unix(),
	}
	
	// Add data to claims
	for key, value := range data {
		claims[key] = value
	}
	
	// Create token
	token := jwt.NewWithClaims(jwt.GetSigningMethod(algorithm), claims)
	
	// Sign and get the complete encoded token as a string
	tokenString, err := token.SignedString(secretKey)
	if err != nil {
		return "", err
	}
	
	return tokenString, nil
}

// RequireAuth is a middleware that enforces authentication
func RequireAuth() gin.HandlerFunc {
	return func(c *gin.Context) {
		var authInfo map[string]interface{}
		var err error
		
		// Try JWT first
		authInfo, err = VerifyToken(c)
		if err != nil {
			// Try API key
			authInfo, err = VerifyAPIKey(c)
			if err != nil {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized", "detail": err.Error()})
				c.Abort()
				return
			}
		}
		
		// Store authentication info in context
		c.Set("auth", authInfo)
		c.Next()
	}
}

// GetAuthUser extracts the username from the authentication context
func GetAuthUser(c *gin.Context) string {
	auth, exists := c.Get("auth")
	if !exists {
		return "unknown"
	}
	
	authMap, ok := auth.(map[string]interface{})
	if !ok {
		return "unknown"
	}
	
	// Check for username (from JWT) or client_id (from API key)
	if username, ok := authMap["username"].(string); ok {
		return username
	}
	
	if clientID, ok := authMap["client_id"].(string); ok {
		return clientID
	}
	
	return "unknown"
}
```

## Models (internal/models/models.go)

```go
package models

import (
	"errors"
	"regexp"
)

// ClusterCreate represents the payload for creating a new cluster
type ClusterCreate struct {
	Name       string                 `json:"name" binding:"required"`
	Namespace  string                 `json:"namespace"`
	K8sVersion string                 `json:"k8s_version"`
	Values     map[string]interface{} `json:"values"`
	Labels     map[string]string      `json:"labels"`
	TTLHours   *int                   `json:"ttl_hours"`
}

// Validate checks if the cluster creation parameters are valid
func (c *ClusterCreate) Validate() error {
	// Validate name (must be a valid Kubernetes name)
	namePattern := regexp.MustCompile(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`)
	if !namePattern.MatchString(c.Name) {
		return errors.New("cluster name must be a valid Kubernetes name (lowercase, alphanumeric, hyphens)")
	}
	
	// Validate namespace if provided
	if c.Namespace != "" && !namePattern.MatchString(c.Namespace) {
		return errors.New("namespace must be a valid Kubernetes name (lowercase, alphanumeric, hyphens)")
	}
	
	// Validate TTL if provided
	if c.TTLHours != nil && *c.TTLHours <= 0 {
		return errors.New("TTL must be a positive number")
	}
	
	// If labels is nil, initialize it
	if c.Labels == nil {
		c.Labels = make(map[string]string)
	}
	
	return nil
}

// ClusterResponse represents the response for a cluster operation
type ClusterResponse struct {
	Name       string            `json:"name"`
	Namespace  string            `json:"namespace"`
	Status     string            `json:"status"`
	Created    string            `json:"created"`
	K8sVersion string            `json:"k8s_version"`
	Kubeconfig string            `json:"kubeconfig,omitempty"`
	Labels     map[string]string `json:"labels"`
}

// ClusterList represents a list of clusters
type ClusterList struct {
	Clusters []ClusterResponse `json:"clusters"`
}
```

## Cluster Service (internal/services/cluster_service.go)

```go
package services

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
	"time"

	"gopkg.in/yaml.v2"
	
	"vcluster-api/internal/config"
	"vcluster-api/internal/models"
)

// CreateCluster creates a new vCluster
func CreateCluster(cluster models.ClusterCreate, createdBy string) (*models.ClusterResponse, error) {
	// Validate input
	err := cluster.Validate()
	if err != nil {
		return nil, err
	}
	
	// Get configuration
	cfg := config.GetConfig()
	
	// Apply namespace prefix if configured
	namespacePrefix := cfg.VCluster.NamespacePrefix
	if namespacePrefix != "" && cluster.Namespace != "" {
		// Only add prefix if not already present
		if !strings.HasPrefix(cluster.Namespace, namespacePrefix) {
			cluster.Namespace = fmt.Sprintf("%s%s", namespacePrefix, cluster.Namespace)
		}
	}
	
	// Prepare command
	cmd := []string{"vcluster", "create", cluster.Name}
	
	// Add namespace if specified
	if cluster.Namespace != "" {
		cmd = append(cmd, "--namespace", cluster.Namespace)
	}
	
	// Add Kubernetes version if specified, otherwise use default
	k8sVersion := cluster.K8sVersion
	if k8sVersion == "" {
		k8sVersion = cfg.VCluster.DefaultK8sVersion
	}
	if k8sVersion != "" {
		cmd = append(cmd, "--kubernetes-version", k8sVersion)
	}
	
	// Add any custom values
	if cluster.Values != nil && len(cluster.Values) > 0 {
		// Create temporary values file
		valuesFile := fmt.Sprintf("/tmp/%s-values.yaml", cluster.Name)
		valuesData, err := yaml.Marshal(cluster.Values)
		if err != nil {
			return nil, fmt.Errorf("error marshalling values: %w", err)
		}
		
		err = ioutil.WriteFile(valuesFile, valuesData, 0644)
		if err != nil {
			return nil, fmt.Errorf("error writing values file: %w", err)
		}
		
		cmd = append(cmd, "--values", valuesFile)
		
		// Clean up temporary file when done
		defer os.Remove(valuesFile)
	}
	
	// Add labels
	if cluster.Labels == nil {
		cluster.Labels = make(map[string]string)
	}
	cluster.Labels["created-by"] = createdBy
	
	for key, value := range cluster.Labels {
		cmd = append(cmd, "--label", fmt.Sprintf("%s=%s", key, value))
	}
	
	// Add TTL annotation if specified, otherwise use default
	ttlHours := cfg.VCluster.DefaultTTLHours
	if cluster.TTLHours != nil {
		ttlHours = *cluster.TTLHours
	}
	if ttlHours > 0 {
		cmd = append(cmd, "--annotation", fmt.Sprintf("ttl-hours=%d", ttlHours))
	}
	
	// Run the command
	log.Printf("Running command: %s", strings.Join(cmd, " "))
	
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()
	
	execCmd := exec.CommandContext(ctx, cmd[0], cmd[1:]...)
	var stdout, stderr bytes.Buffer
	execCmd.Stdout = &stdout
	execCmd.Stderr = &stderr
	
	err = execCmd.Run()
	if err != nil {
		return nil, fmt.Errorf("failed to create vCluster: %s - %w", stderr.String(), err)
	}
	
	// Get cluster details
	return GetClusterDetails(cluster.Name, cluster.Namespace)
}

// DeleteCluster deletes a vCluster
func DeleteCluster(name string, namespace string) error {
	// Get configuration
	cfg := config.GetConfig()
	
	// Apply namespace prefix if configured
	if namespace != "" {
		namespacePrefix := cfg.VCluster.NamespacePrefix
		if namespacePrefix != "" && !strings.HasPrefix(namespace, namespacePrefix) {
			namespace = fmt.Sprintf("%s%s", namespacePrefix, namespace)
		}
	}
	
	// Prepare command
	cmd := []string{"vcluster", "delete", name}
	
	// Add namespace if specified
	if namespace != "" {
		cmd = append(cmd, "--namespace", namespace)
	}
	
	// Run the command
	log.Printf("Running command: %s", strings.Join(cmd, " "))
	
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()
	
	execCmd := exec.CommandContext(ctx, cmd[0], cmd[1:]...)
	var stdout, stderr bytes.Buffer
	execCmd.Stdout = &stdout
	execCmd.Stderr = &stderr
	
	err := execCmd.Run()
	if err != nil {
		return fmt.Errorf("failed to delete vCluster: %s - %w", stderr.String(), err)
	}
	
	return nil
}

// ListClusters returns a list of all vClusters
func ListClusters(namespace string) ([]models.ClusterResponse, error) {
	// Get configuration
	cfg := config.GetConfig()
	
	// Apply namespace prefix if configured
	if namespace != "" {
		namespacePrefix := cfg.VCluster.NamespacePrefix
		if namespacePrefix != "" && !strings.HasPrefix(namespace, namespacePrefix) {
			namespace = fmt.Sprintf("%s%s", namespacePrefix, namespace)
		}
	}
	
	// Prepare command
	cmd := []string{"vcluster", "list", "-o", "json"}
	
	// Add namespace if specified
	if namespace != "" {
		cmd = append(cmd, "--namespace", namespace)
	}
	
	// Run the command
	log.Printf("Running command: %s", strings.Join(cmd, " "))
	
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	
	execCmd := exec.CommandContext(ctx, cmd[0], cmd[1:]...)
	var stdout, stderr bytes.Buffer
	execCmd.Stdout = &stdout
	execCmd.Stderr = &stderr
	
	err := execCmd.Run()
	if err != nil {
		return nil, fmt.Errorf("failed to list vClusters: %s - %w", stderr.String(), err)
	}
	
	// Parse the output
	var clustersData []map[string]interface{}
	err = json.Unmarshal(stdout.Bytes(), &clustersData)
	if err != nil {
		return nil, fmt.Errorf("failed to parse vcluster list output: %w", err)
	}
	
	// Convert to response model
	clusters := make([]models.ClusterResponse, 0, len(clustersData))
	for _, item := range clustersData {
		// Extract labels
		labels := make(map[string]string)
		if labelData, ok := item["labels"].(map[string]interface{}); ok {
			for k, v := range labelData {
				if strValue, ok := v.(string); ok {
					labels[k] = strValue
				}
			}
		}
		
		cluster := models.ClusterResponse{
			Name:       getString(item, "name"),
			Namespace:  getString(item, "namespace"),
			Status:     getString(item, "status"),
			Created:    getString(item, "created"),
			K8sVersion: getString(item, "kubernetes_version"),
			Kubeconfig: "",
			Labels:     labels,
		}
		clusters = append(clusters, cluster)
	}
	
	return clusters, nil
}

// GetClusterDetails returns detailed information about a specific vCluster
func GetClusterDetails(name string, namespace string) (*models.ClusterResponse, error) {
	// First check if cluster exists
	clusters, err := ListClusters(namespace)
	if err != nil {
		return nil, err
	}
	
	// Find the cluster in the list
	var targetCluster *models.ClusterResponse
	for i, cluster := range clusters {
		if cluster.Name == name {
			targetCluster = &clusters[i]
			break
		}
	}
	
	if targetCluster == nil {
		return nil, errors.New("cluster not found")
	}
	
	// Get configuration
	cfg := config.GetConfig()
	
	// Apply namespace prefix if configured
	ns := targetCluster.Namespace
	if namespace != "" {
		ns = namespace
		namespacePrefix := cfg.VCluster.NamespacePrefix
		if namespacePrefix != "" && !strings.HasPrefix(ns, namespacePrefix) {
			ns = fmt.Sprintf("%s%s", namespacePrefix, ns)
		}
	}
	
	// Get kubeconfig
	cmd := []string{"vcluster", "connect", name, "--print"}
	
	if ns != "" {
		cmd = append(cmd, "--namespace", ns)
	}
	
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	
	execCmd := exec.CommandContext(ctx, cmd[0], cmd[1:]...)
	var stdout, stderr bytes.Buffer
	execCmd.Stdout = &stdout
	execCmd.Stderr = &stderr
	
	err = execCmd.Run()
	if err == nil {
		targetCluster.Kubeconfig = stdout.String()
	} else {
		log.Printf("Warning: Failed to get kubeconfig: %s", stderr.String())
	}
	
	return targetCluster, nil
}

// Helper function to get string value from map
func getString(data map[string]interface{}, key string) string {
	if val, ok := data[key].(string); ok {
		return val
	}
	return ""
}
```

## Pruning Service (internal/services/pruning_service.go)

```go
package services

import (
	"log"
	"strconv"
	"time"
)

// PruneExpiredClusters finds and deletes clusters that have exceeded their TTL
func PruneExpiredClusters() {
	log.Println("Starting cluster pruning job")
	
	// Get all clusters
	clusters, err := ListClusters("")
	if err != nil {
		log.Printf("Error listing clusters for pruning: %v", err)
		return
	}
	
	// Track clusters processed
	processed := 0
	deleted := 0
	
	// Check each cluster for TTL expiration
	for _, cluster := range clusters {
		processed++
		
		// Check if the cluster has a TTL annotation
		ttlHoursStr, hasTTL := cluster.Labels["ttl-hours"]
		if !hasTTL {
			// Try annotations directly
			if annotations, ok := cluster.Labels["annotations"]; ok {
				sections := parseAnnotations(annotations)
				if ttlStr, ok := sections["ttl-hours"]; ok {
					ttlHoursStr = ttlStr
					hasTTL = true
				}
			}
		}
		
		if !hasTTL {
			continue
		}
		
		ttlHours, err := strconv.Atoi(ttlHoursStr)
		if err != nil {
			log.Printf("Warning: Error parsing TTL for cluster %s: %v", cluster.Name, err)
			continue
		}
		
		// Parse creation time
		creationTime, err := parseTime(cluster.Created)
		if err !=nil {
			log.Printf("Warning: Error parsing creation time for cluster %s: %v", cluster.Name, err)
			continue
		}
		
		// Calculate expiry time
		expiryTime := creationTime.Add(time.Duration(ttlHours) * time.Hour)
		
		// Check if the cluster has expired
		if time.Now().After(expiryTime) {
			log.Printf("Deleting expired cluster: %s in namespace %s", cluster.Name, cluster.Namespace)
			err := DeleteCluster(cluster.Name, cluster.Namespace)
			if err != nil {
				log.Printf("Error deleting expired cluster %s: %v", cluster.Name, err)
			} else {
				deleted++
			}
		} else {
			// Calculate time until expiration
			timeLeft := expiryTime.Sub(time.Now())
			log.Printf("Cluster %s will expire in %v", cluster.Name, timeLeft)
		}
	}
	
	log.Printf("Finished cluster pruning job. Processed %d clusters, deleted %d expired clusters.", processed, deleted)
}

// SetupPruningScheduler sets up a periodic pruning job
func SetupPruningScheduler(intervalHours int) {
	if intervalHours <= 0 {
		intervalHours = 1
	}
	
	log.Printf("Cluster pruning scheduler set up to run every %d hour(s)", intervalHours)
	
	// Run initial pruning
	go PruneExpiredClusters()
	
	// Set up periodic pruning
	go func() {
		ticker := time.NewTicker(time.Duration(intervalHours) * time.Hour)
		defer ticker.Stop()
		
		for range ticker.C {
			PruneExpiredClusters()
		}
	}()
}

// Helper function to parse annotations
func parseAnnotations(annotations string) map[string]string {
	result := make(map[string]string)
	// In a real implementation, this would parse the annotation string
	// This is a simplified placeholder
	return result
}

// Helper function to parse time
func parseTime(timeStr string) (time.Time, error) {
	// Try common formats
	layouts := []string{
		time.RFC3339,
		"2006-01-02T15:04:05Z",
		"2006-01-02T15:04:05",
		"2006-01-02 15:04:05",
		"2006-01-02",
	}
	
	for _, layout := range layouts {
		t, err := time.Parse(layout, timeStr)
		if err == nil {
			return t, nil
		}
	}
	
	// Use a default parsing method
	return time.Parse(time.RFC3339, timeStr)
}
```

## Cluster Handler (internal/handlers/clusters.go)

```go
package handlers

import (
	"log"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	
	"vcluster-api/internal/auth"
	"vcluster-api/internal/models"
	"vcluster-api/internal/services"
)

// RegisterClusterRoutes registers the cluster-related routes
func RegisterClusterRoutes(router *gin.RouterGroup) {
	clusters := router.Group("/clusters")
	clusters.Use(auth.RequireAuth())
	
	clusters.POST("/", createNewCluster)
	clusters.GET("/", getAllClusters)
	clusters.GET("/:name", getCluster)
	clusters.DELETE("/:name", removeCluster)
}

// createNewCluster handles the creation of a new virtual cluster
func createNewCluster(c *gin.Context) {
	var clusterReq models.ClusterCreate
	
	if err := c.ShouldBindJSON(&clusterReq); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request", "detail": err.Error()})
		return
	}
	
	if err := clusterReq.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed", "detail": err.Error()})
		return
	}
	
	username := auth.GetAuthUser(c)
	
	startTime := time.Now()
	log.Printf("Creating cluster: %s by %s", clusterReq.Name, username)
	
	result, err := services.CreateCluster(clusterReq, username)
	if err != nil {
		log.Printf("Failed to create cluster: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create cluster", "detail": err.Error()})
		return
	}
	
	// Log creation time
	creationTime := time.Since(startTime)
	log.Printf("Cluster %s created in %.2f seconds", clusterReq.Name, creationTime.Seconds())
	
	// Return result
	c.JSON(http.StatusCreated, result)
}

// getAllClusters handles listing all virtual clusters
func getAllClusters(c *gin.Context) {
	namespace := c.Query("namespace")
	
	clusters, err := services.ListClusters(namespace)
	if err != nil {
		log.Printf("Failed to list clusters: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list clusters", "detail": err.Error()})
		return
	}
	
	c.JSON(http.StatusOK, models.ClusterList{
		Clusters: clusters,
	})
}

// getCluster handles getting a specific virtual cluster
func getCluster(c *gin.Context) {
	name := c.Param("name")
	namespace := c.Query("namespace")
	
	cluster, err := services.GetClusterDetails(name, namespace)
	if err != nil {
		log.Printf("Failed to get cluster details for %s: %v", name, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get cluster details", "detail": err.Error()})
		return
	}
	
	if cluster == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Cluster not found"})
		return
	}
	
	c.JSON(http.StatusOK, cluster)
}

// removeCluster handles deleting a virtual cluster
func removeCluster(c *gin.Context) {
	name := c.Param("name")
	namespace := c.Query("namespace")
	
	username := auth.GetAuthUser(c)
	log.Printf("Deleting cluster: %s by %s", name, username)
	
	err := services.DeleteCluster(name, namespace)
	if err != nil {
		log.Printf("Failed to delete cluster %s: %v", name, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete cluster", "detail": err.Error()})
		return
	}
	
	log.Printf("Deleted cluster: %s", name)
	c.Status(http.StatusNoContent)
}
```

## Webhooks Handler (internal/handlers/webhooks.go)

```go
package handlers

import (
	"github.com/gin-gonic/gin"
	"log"
	"net/http"
	
	"vcluster-api/internal/config"
)

// RegisterWebhookRoutes registers routes for webhooks
func RegisterWebhookRoutes(router *gin.RouterGroup) {
	webhooks := router.Group("/webhooks")
	
	// GitHub webhooks
	cfg := config.GetConfig()
	if cfg.Webhooks.GitHub.Enabled {
		webhooks.POST("/github", handleGitHubWebhook)
	}
	
	// BitBucket webhooks
	if cfg.Webhooks.Bitbucket.Enabled {
		webhooks.POST("/bitbucket", handleBitbucketWebhook)
	}
}

// handleGitHubWebhook processes GitHub webhook events
func handleGitHubWebhook(c *gin.Context) {
	// Get configuration
	cfg := config.GetConfig()
	secret := cfg.Webhooks.GitHub.Secret
	
	// Verify webhook signature if secret is configured
	if secret != "" {
		signature := c.GetHeader("X-Hub-Signature-256")
		if signature == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Missing X-Hub-Signature-256 header"})
			return
		}
		
		// TODO: Implement signature verification
	}
	
	// Get the event type
	event := c.GetHeader("X-GitHub-Event")
	if event == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing X-GitHub-Event header"})
		return
	}
	
	// Read and parse the payload
	var payload map[string]interface{}
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON payload"})
		return
	}
	
	log.Printf("Received GitHub webhook event: %s", event)
	
	// Process the event based on its type
	switch event {
	case "push":
		// TODO: Handle push event
	case "pull_request":
		// TODO: Handle pull request event
	case "issue_comment":
		// TODO: Handle issue comment event
	default:
		log.Printf("Unhandled GitHub event: %s", event)
	}
	
	c.JSON(http.StatusOK, gin.H{"status": "Webhook received"})
}

// handleBitbucketWebhook processes Bitbucket webhook events
func handleBitbucketWebhook(c *gin.Context) {
	// Get configuration
	cfg := config.GetConfig()
	secret := cfg.Webhooks.Bitbucket.Secret
	
	// Verify webhook if secret is configured
	if secret != "" {
		// TODO: Implement Bitbucket webhook verification
	}
	
	// Get the event type
	event := c.GetHeader("X-Event-Key")
	if event == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing X-Event-Key header"})
		return
	}
	
	// Read and parse the payload
	var payload map[string]interface{}
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON payload"})
		return
	}
	
	log.Printf("Received Bitbucket webhook event: %s", event)
	
	// Process the event based on its type
	switch event {
	case "repo:push":
		// TODO: Handle push event
	case "pullrequest:created", "pullrequest:updated":
		// TODO: Handle pull request events
	default:
		log.Printf("Unhandled Bitbucket event: %s", event)
	}
	
	c.JSON(http.StatusOK, gin.H{"status": "Webhook received"})
}
```

## Dynamic Handler (internal/handlers/dynamic.go)

```go
package handlers

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/gin-gonic/gin"
	"gopkg.in/yaml.v2"
	
	"vcluster-api/internal/auth"
	"vcluster-api/internal/config"
)

// DynamicEndpoint represents a dynamic API endpoint
type DynamicEndpoint struct {
	Path        string            `yaml:"path"`
	Method      string            `yaml:"method"`
	Command     string            `yaml:"command"`
	Args        []string          `yaml:"args"`
	Description string            `yaml:"description"`
	RequireAuth bool              `yaml:"require_auth"`
	Responses   map[string]string `yaml:"responses"`
}

// DynamicConfig represents the dynamic endpoints configuration
type DynamicConfig struct {
	Endpoints []DynamicEndpoint `yaml:"endpoints"`
}

// RegisterDynamicRoutes loads and registers dynamic endpoints
func RegisterDynamicRoutes(router *gin.Engine) {
	// Get configuration
	cfg := config.GetConfig()
	
	// Load dynamic endpoints configuration
	endpointsConfig := loadDynamicEndpoints(cfg.DynamicEndpoints.ConfigPath)
	if endpointsConfig == nil {
		log.Println("No dynamic endpoints loaded")
		return
	}
	
	// Register each endpoint
	for i, endpoint := range endpointsConfig.Endpoints {
		method := strings.ToUpper(endpoint.Method)
		if method == "" {
			method = "GET"
		}
		
		// Create handler
		handler := createDynamicHandler(endpoint)
		
		// Register route
		path := endpoint.Path
		if !strings.HasPrefix(path, "/") {
			path = "/" + path
		}
		
		// Add authentication middleware if required
		if endpoint.RequireAuth {
			log.Printf("Registering dynamic endpoint with auth: %s %s", method, path)
			router.Handle(method, path, auth.RequireAuth(), handler)
		} else {
			log.Printf("Registering dynamic endpoint: %s %s", method, path)
			router.Handle(method, path, handler)
		}
	}
}

// loadDynamicEndpoints loads dynamic endpoints from a YAML file
func loadDynamicEndpoints(configPath string) *DynamicConfig {
	// Check if file exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		log.Printf("Dynamic endpoints config file not found: %s", configPath)
		return nil
	}
	
	// Read file
	data, err := ioutil.ReadFile(configPath)
	if err != nil {
		log.Printf("Error reading dynamic endpoints config: %v", err)
		return nil
	}
	
	// Parse YAML
	var config DynamicConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		log.Printf("Error parsing dynamic endpoints config: %v", err)
		return nil
	}
	
	log.Printf("Loaded %d dynamic endpoints from %s", len(config.Endpoints), configPath)
	return &config
}

// createDynamicHandler creates a handler function for a dynamic endpoint
func createDynamicHandler(endpoint DynamicEndpoint) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Replace path parameters in command and args
		cmd := endpoint.Command
		args := make([]string, len(endpoint.Args))
		
		// Copy args to avoid modifying the original
		copy(args, endpoint.Args)
		
		// Replace path params in command and args
		for _, param := range c.Params {
			placeholder := "{" + param.Key + "}"
			cmd = strings.ReplaceAll(cmd, placeholder, param.Value)
			
			for i, arg := range args {
				args[i] = strings.ReplaceAll(arg, placeholder, param.Value)
			}
		}
		
		// Replace query parameters
		for key, values := range c.Request.URL.Query() {
			if len(values) > 0 {
				placeholder := "{query." + key + "}"
				queryValue := values[0]
				
				cmd = strings.ReplaceAll(cmd, placeholder, queryValue)
				
				for i, arg := range args {
					args[i] = strings.ReplaceAll(arg, placeholder, queryValue)
				}
			}
		}
		
		// Get authentication info if present
		if authInfo, exists := c.Get("auth"); exists {
			if authData, ok := authInfo.(map[string]interface{}); ok {
				// Replace auth placeholders
				username := fmt.Sprintf("%v", authData["username"])
				
				cmd = strings.ReplaceAll(cmd, "{auth.username}", username)
				
				for i, arg := range args {
					args[i] = strings.ReplaceAll(arg, "{auth.username}", username)
				}
			}
		}
		
		// Absolute path for security
		cmdPath, err := exec.LookPath(cmd)
		if err != nil {
			// Try looking in the current directory and PATH
			cmdPath = filepath.Clean(cmd)
		}
		
		// Execute command
		log.Printf("Executing command: %s %s", cmdPath, strings.Join(args, " "))
		execCmd := exec.Command(cmdPath, args...)
		
		// Read request body if present
		if c.Request.ContentLength > 0 {
			body, err := ioutil.ReadAll(c.Request.Body)
			if err != nil {
				c.JSON(http.StatusBadRequest, gin.H{"error": "Error reading request body"})
				return
			}
			
			execCmd.Stdin = strings.NewReader(string(body))
		}
		
		// Execute command
		output, err := execCmd.CombinedOutput()
		if err != nil {
			log.Printf("Command failed: %v - Output: %s", err, string(output))
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Command execution failed", "output": string(output)})
			return
		}
		
		// Try to parse output as JSON
		var result interface{}
		if json.Unmarshal(output, &result) == nil {
			c.JSON(http.StatusOK, result)
		} else {
			c.String(http.StatusOK, string(output))
		}
	}
}
```

## Dockerfile

```dockerfile
FROM golang:1.19-alpine AS builder

WORKDIR /app

# Copy go mod and sum files
COPY go.mod go.sum ./

# Download all dependencies
RUN go mod download

# Copy the source code
COPY . .

# Build the application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o vcluster-api ./cmd/server

FROM alpine:3.16

WORKDIR /app

# Install dependencies
RUN apk --no-cache add curl bash

# Install vcluster CLI
RUN curl -L -o vcluster "https://github.com/loft-sh/vcluster/releases/latest/download/vcluster-linux-amd64" && \
    install -c -m 0755 vcluster /usr/local/bin && \
    rm -f vcluster

# Install kubectl
RUN curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" && \
    install -c -m 0755 kubectl /usr/local/bin && \
    rm -f kubectl

# Copy binary from builder
COPY --from=builder /app/vcluster-api .

# Create config directory
RUN mkdir -p /app/config

# Copy default configuration files
COPY config/config.yaml /app/config/config.yaml
COPY config/endpoints.yaml /app/config/endpoints.yaml

# Run the application
CMD ["./vcluster-api"]
```

## Go Module (go.mod)

```
module vcluster-api

go 1.19

require (
	github.com/gin-contrib/cors v1.4.0
	github.com/gin-gonic/gin v1.8.2
	github.com/golang-jwt/jwt/v4 v4.5.0
	gopkg.in/yaml.v2 v2.4.0
)

require (
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.11.2 // indirect
	github.com/goccy/go-json v0.10.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/leodido/go-urn v1.2.1 // indirect
	github.com/mattn/go-isatty v0.0.17 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.0.6 // indirect
	github.com/ugorji/go/codec v1.2.9 // indirect
	golang.org/x/crypto v0.6.0 // indirect
	golang.org/x/net v0.7.0 // indirect
	golang.org/x/sys v0.5.0 // indirect
	golang.org/x/text v0.7.0 // indirect
	google.golang.org/protobuf v1.28.1 // indirect
)
```
