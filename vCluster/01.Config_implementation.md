# Enhanced vCluster API with Dynamic Configuration

I'll extend the previous implementation to support YAML configuration and dynamic API endpoints. This will make the system more flexible and easier to maintain.

## Configuration System Implementation

First, let's add a configuration system that allows loading settings from a YAML file:

### 1. Configuration Module (app/config/config.py)

```python
import os
import yaml
import logging
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)

class AppConfig:
    """Configuration manager for the vCluster API service"""
    
    _instance = None
    
    def __new__(cls):
        """Singleton pattern to ensure only one config instance exists"""
        if cls._instance is None:
            cls._instance = super(AppConfig, cls).__new__(cls)
            cls._instance._load_config()
        return cls._instance
    
    def _load_config(self):
        """Load configuration from YAML file or environment variables"""
        self.config = {}
        
        # Default configuration
        self.config = {
            "server": {
                "host": "0.0.0.0",
                "port": 8000,
                "debug": False,
                "allowed_origins": []
            },
            "auth": {
                "jwt": {
                    "secret_key": "",
                    "algorithm": "HS256",
                    "token_expire_minutes": 30
                },
                "api_keys": {}
            },
            "webhooks": {
                "github": {
                    "enabled": True,
                    "secret": ""
                },
                "bitbucket": {
                    "enabled": True,
                    "secret": ""
                }
            },
            "vcluster": {
                "default_k8s_version": "1.25",
                "default_ttl_hours": 24,
                "pruning_interval_hours": 1,
                "namespace_prefix": ""
            },
            "dynamic_endpoints": {
                "enabled": True,
                "config_path": "endpoints.yaml"
            }
        }
        
        # Try to load config from file
        config_path = os.getenv("CONFIG_PATH", "/app/config/config.yaml")
        try:
            if os.path.exists(config_path):
                with open(config_path, 'r') as f:
                    file_config = yaml.safe_load(f)
                    self._merge_config(self.config, file_config)
                logger.info(f"Loaded configuration from {config_path}")
            else:
                logger.warning(f"Config file {config_path} not found, using defaults and environment variables")
        except Exception as e:
            logger.error(f"Error loading config file: {str(e)}")
        
        # Override with environment variables
        self._load_from_env()
        
    def _merge_config(self, base: Dict[str, Any], override: Dict[str, Any]) -> Dict[str, Any]:
        """Recursively merge configuration dictionaries"""
        for key, value in override.items():
            if key in base and isinstance(base[key], dict) and isinstance(value, dict):
                base[key] = self._merge_config(base[key], value)
            else:
                base[key] = value
        return base
    
    def _load_from_env(self):
        """Load configuration from environment variables"""
        # JWT settings
        if os.getenv("JWT_SECRET_KEY"):
            self.config["auth"]["jwt"]["secret_key"] = os.getenv("JWT_SECRET_KEY")
        if os.getenv("JWT_ALGORITHM"):
            self.config["auth"]["jwt"]["algorithm"] = os.getenv("JWT_ALGORITHM")
        if os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES"):
            self.config["auth"]["jwt"]["token_expire_minutes"] = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES"))
        
        # Webhook secrets
        if os.getenv("GITHUB_WEBHOOK_SECRET"):
            self.config["webhooks"]["github"]["secret"] = os.getenv("GITHUB_WEBHOOK_SECRET")
        if os.getenv("BITBUCKET_WEBHOOK_SECRET"):
            self.config["webhooks"]["bitbucket"]["secret"] = os.getenv("BITBUCKET_WEBHOOK_SECRET")
        
        # Server settings
        if os.getenv("SERVER_HOST"):
            self.config["server"]["host"] = os.getenv("SERVER_HOST")
        if os.getenv("SERVER_PORT"):
            self.config["server"]["port"] = int(os.getenv("SERVER_PORT"))
        if os.getenv("DEBUG").lower() in ["true", "1", "yes"] if os.getenv("DEBUG") else False:
            self.config["server"]["debug"] = True
        if os.getenv("ALLOWED_ORIGINS"):
            self.config["server"]["allowed_origins"] = os.getenv("ALLOWED_ORIGINS").split(",")
        
        # vCluster settings
        if os.getenv("DEFAULT_K8S_VERSION"):
            self.config["vcluster"]["default_k8s_version"] = os.getenv("DEFAULT_K8S_VERSION")
        if os.getenv("DEFAULT_TTL_HOURS"):
            self.config["vcluster"]["default_ttl_hours"] = int(os.getenv("DEFAULT_TTL_HOURS"))
        if os.getenv("PRUNING_INTERVAL_HOURS"):
            self.config["vcluster"]["pruning_interval_hours"] = int(os.getenv("PRUNING_INTERVAL_HOURS"))
        if os.getenv("NAMESPACE_PREFIX"):
            self.config["vcluster"]["namespace_prefix"] = os.getenv("NAMESPACE_PREFIX")
    
    def get(self, path: str, default=None) -> Any:
        """Get a configuration value by dot-separated path"""
        try:
            result = self.config
            for key in path.split('.'):
                result = result[key]
            return result
        except (KeyError, TypeError):
            return default

# Create singleton instance
config = AppConfig()
```

### 2. Sample Configuration YAML (config/config.yaml)

```yaml
server:
  host: 0.0.0.0
  port: 8000
  debug: false
  allowed_origins:
    - https://portal.example.com
    - https://dev-portal.example.com

auth:
  jwt:
    algorithm: HS256
    token_expire_minutes: 60
  api_keys:
    ci-system: aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d
    monitoring: 7d793037a0760186574b0282f2f435e7

webhooks:
  github:
    enabled: true
  bitbucket:
    enabled: true

vcluster:
  default_k8s_version: "1.25"
  default_ttl_hours: 24
  pruning_interval_hours: 1
  namespace_prefix: "vc-"

dynamic_endpoints:
  enabled: true
  config_path: "/app/config/endpoints.yaml"
```

## Dynamic Endpoint Configuration

Now, let's implement the dynamic endpoint system:

### 3. Dynamic Endpoints Configuration (config/endpoints.yaml)

```yaml
# Dynamic API Endpoints Configuration
#
# This file defines custom API endpoints that map to vcluster and kubectl commands.
# Each endpoint can be configured with parameters, validation rules, and permissions.
#
# Format:
# endpoints:
#   - path: "/api/path"           # URL path for the endpoint
#     method: "GET|POST|DELETE"   # HTTP method
#     command: "vcluster|kubectl" # Command to execute
#     args: ["arg1", "arg2"]      # Fixed arguments
#     description: "Description"  # What this endpoint does
#     enabled: true               # Whether this endpoint is enabled
#     auth: "jwt|api_key|none"    # Authentication method required
#     parameters:                 # Parameters that can be passed from the request
#       - name: "param_name"      # Parameter name
#         type: "string|int|bool" # Parameter type
#         required: true|false    # Whether parameter is required
#         in: "path|query|body"   # Where to get parameter from
#         description: "Desc"     # Parameter description
#         default: "value"        # Default value if not provided
#         validation:             # Validation rules
#           pattern: "regex"      # Regex pattern for validation
#           min: 1                # Minimum value (for int)
#           max: 100              # Maximum value (for int)
#           options:              # Allowed values
#             - "option1"
#             - "option2"
#     responses:                  # Possible responses
#       200:                      # HTTP status code
#         description: "Success"  # Response description
#       400:
#         description: "Bad request"

endpoints:
  # List all virtual clusters in the system
  - path: "/api/vclusters"
    method: "GET"
    command: "vcluster"
    args: ["list", "-o", "json"]
    description: "List all virtual clusters in the system"
    enabled: true
    auth: "jwt"
    parameters:
      - name: "namespace"
        type: "string"
        required: false
        in: "query"
        description: "Filter clusters by namespace"
        validation:
          pattern: "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
    responses:
      200:
        description: "List of virtual clusters"
      401:
        description: "Unauthorized"
      500:
        description: "Internal server error"

  # Create a new virtual cluster
  - path: "/api/vclusters"
    method: "POST"
    command: "vcluster"
    args: ["create"]
    description: "Create a new virtual cluster"
    enabled: true
    auth: "jwt"
    parameters:
      - name: "name"
        type: "string"
        required: true
        in: "body"
        description: "Name of the virtual cluster"
        validation:
          pattern: "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
      - name: "namespace"
        type: "string"
        required: false
        in: "body"
        description: "Kubernetes namespace for the virtual cluster"
      - name: "k8s_version"
        type: "string"
        required: false
        in: "body"
        description: "Kubernetes version to use"
        default: "1.25"
        validation:
          options:
            - "1.24"
            - "1.25"
            - "1.26"
      - name: "ttl_hours"
        type: "int"
        required: false
        in: "body"
        description: "Time-to-live in hours before automatic deletion"
        default: 24
        validation:
          min: 1
          max: 168
    responses:
      201:
        description: "Virtual cluster created successfully"
      400:
        description: "Invalid request parameters"
      401:
        description: "Unauthorized"
      500:
        description: "Failed to create virtual cluster"

  # Delete a virtual cluster
  - path: "/api/vclusters/{name}"
    method: "DELETE"
    command: "vcluster"
    args: ["delete"]
    description: "Delete a virtual cluster"
    enabled: true
    auth: "jwt"
    parameters:
      - name: "name"
        type: "string"
        required: true
        in: "path"
        description: "Name of the virtual cluster to delete"
      - name: "namespace"
        type: "string"
        required: false
        in: "query"
        description: "Namespace of the virtual cluster"
    responses:
      204:
        description: "Virtual cluster deleted successfully"
      401:
        description: "Unauthorized"
      404:
        description: "Virtual cluster not found"
      500:
        description: "Failed to delete virtual cluster"

  # Get virtual cluster details
  - path: "/api/vclusters/{name}"
    method: "GET"
    command: "vcluster"
    args: ["connect", "--print"]
    description: "Get virtual cluster details including kubeconfig"
    enabled: true
    auth: "jwt"
    parameters:
      - name: "name"
        type: "string"
        required: true
        in: "path"
        description: "Name of the virtual cluster"
      - name: "namespace"
        type: "string"
        required: false
        in: "query"
        description: "Namespace of the virtual cluster"
    responses:
      200:
        description: "Virtual cluster details"
      401:
        description: "Unauthorized"
      404:
        description: "Virtual cluster not found"
      500:
        description: "Failed to get virtual cluster details"

  # Execute kubectl command in a virtual cluster
  - path: "/api/vclusters/{name}/exec"
    method: "POST"
    command: "kubectl"
    description: "Execute kubectl command in a virtual cluster"
    enabled: true
    auth: "jwt"
    parameters:
      - name: "name"
        type: "string"
        required: true
        in: "path"
        description: "Name of the virtual cluster"
      - name: "namespace"
        type: "string"
        required: false
        in: "query"
        description: "Namespace of the virtual cluster"
      - name: "command"
        type: "string"
        required: true
        in: "body"
        description: "kubectl command to execute (e.g., 'get pods')"
    responses:
      200:
        description: "Command executed successfully"
      401:
        description: "Unauthorized"
      404:
        description: "Virtual cluster not found"
      500:
        description: "Failed to execute command"
```

## Dynamic Endpoint Router Implementation

Now, let's implement the dynamic endpoint functionality:

### 4. Dynamic Endpoint Handler (app/routers/dynamic.py)

```python
from fastapi import APIRouter, Depends, HTTPException, Request, status
from fastapi.responses import JSONResponse, Response
import yaml
import os
import logging
import asyncio
import json
import re
from typing import Dict, Any, List, Optional, Union

from app.auth.authenticator import verify_token, verify_api_key
from app.config.config import config

logger = logging.getLogger(__name__)

router = APIRouter(tags=["dynamic"])

# Load dynamic endpoint configuration
def load_endpoints_config():
    """Load the dynamic endpoints configuration from YAML file"""
    endpoints_path = config.get("dynamic_endpoints.config_path")
    if not endpoints_path or not os.path.exists(endpoints_path):
        logger.warning(f"Dynamic endpoints config file not found at {endpoints_path}")
        return {"endpoints": []}
    
    try:
        with open(endpoints_path, 'r') as f:
            return yaml.safe_load(f)
    except Exception as e:
        logger.error(f"Error loading dynamic endpoints config: {str(e)}")
        return {"endpoints": []}

# Process parameter value based on its type
def process_param_value(value: str, param_type: str) -> Any:
    """Convert parameter value to the specified type"""
    if param_type == "int":
        return int(value)
    elif param_type == "bool":
        return value.lower() in ["true", "1", "yes"]
    # Default to string for all other types
    return value

# Validate parameter value against validation rules
def validate_param(name: str, value: Any, validation: Dict[str, Any]) -> bool:
    """Validate parameter value against provided validation rules"""
    if not validation:
        return True
        
    if isinstance(value, str) and "pattern" in validation:
        if not re.match(validation["pattern"], value):
            raise ValueError(f"Parameter '{name}' does not match pattern '{validation['pattern']}'")
            
    if isinstance(value, int):
        if "min" in validation and value < validation["min"]:
            raise ValueError(f"Parameter '{name}' must be at least {validation['min']}")
        if "max" in validation and value > validation["max"]:
            raise ValueError(f"Parameter '{name}' must not exceed {validation['max']}")
            
    if "options" in validation and value not in validation["options"]:
        raise ValueError(f"Parameter '{name}' must be one of: {', '.join(map(str, validation['options']))}")
        
    return True

# Build command args from endpoint config and request parameters
async def build_command_args(endpoint: Dict[str, Any], request: Request, path_params: Dict[str, str]) -> List[str]:
    """Build command arguments from endpoint config and request parameters"""
    args = endpoint.get("args", [])[:]  # Copy the args list
    
    # Insert the cluster name parameter if needed
    if "{name}" in endpoint.get("path", "") and "name" in path_params:
        # Find the position to insert the name (usually after the command itself)
        name_pos = 1  # Default position after the command
        args.insert(name_pos, path_params["name"])
    
    # Process parameters from the request
    body_params = {}
    if request.method in ["POST", "PUT", "PATCH"]:
        try:
            body_params = await request.json()
        except Exception:
            body_params = {}
    
    for param in endpoint.get("parameters", []):
        param_name = param["name"]
        param_type = param.get("type", "string")
        param_in = param.get("in", "query")
        param_required = param.get("required", False)
        param_default = param.get("default")
        
        # Get parameter value from the appropriate location
        value = None
        if param_in == "path" and param_name in path_params:
            value = path_params[param_name]
        elif param_in == "query":
            value = request.query_params.get(param_name)
        elif param_in == "body" and param_name in body_params:
            value = body_params[param_name]
        
        # Use default value if provided and no value found
        if value is None and param_default is not None:
            value = param_default
        
        # Check if required parameter is missing
        if param_required and value is None:
            raise ValueError(f"Required parameter '{param_name}' is missing")
        
        # Skip if no value and not required
        if value is None:
            continue
        
        # Convert to appropriate type
        try:
            value = process_param_value(value, param_type)
        except (ValueError, TypeError):
            raise ValueError(f"Invalid value for parameter '{param_name}', expected {param_type}")
        
        # Validate value
        validate_param(param_name, value, param.get("validation", {}))
        
        # Add to command args with appropriate flag
        if param_in == "path":
            # Path parameters are already inserted directly
            continue
        elif param_name == "namespace":
            args.extend(["--namespace", str(value)])
        elif param_name == "command":
            # Special handling for kubectl command parameter
            command_parts = str(value).split()
            args.extend(command_parts)
        elif param_in == "query" or param_in == "body":
            # Use kebab-case for flags (convert snake_case to kebab-case)
            flag_name = param_name.replace("_", "-")
            
            # Handle boolean flags
            if isinstance(value, bool):
                if value:
                    args.append(f"--{flag_name}")
            else:
                # Regular flag with value
                args.extend([f"--{flag_name}", str(value)])
    
    return args

# Execute command and return the result
async def execute_command(command: str, args: List[str]) -> Dict[str, Any]:
    """Execute the command with given arguments and return the result"""
    cmd = [command] + args
    logger.info(f"Executing command: {' '.join(cmd)}")
    
    try:
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await process.communicate()
        
        result = {
            "success": process.returncode == 0,
            "returncode": process.returncode
        }
        
        if stdout:
            stdout_text = stdout.decode().strip()
            try:
                # Try to parse as JSON if it looks like JSON
                if stdout_text.startswith("{") or stdout_text.startswith("["):
                    result["data"] = json.loads(stdout_text)
                else:
                    result["output"] = stdout_text
            except json.JSONDecodeError:
                result["output"] = stdout_text
        
        if stderr and process.returncode != 0:
            result["error"] = stderr.decode().strip()
            
        return result
    except Exception as e:
        logger.error(f"Error executing command: {str(e)}")
        return {
            "success": False,
            "error": str(e)
        }

# Initialize the dynamic endpoints
def init_dynamic_endpoints():
    """Initialize the dynamic endpoints from configuration"""
    if not config.get("dynamic_endpoints.enabled", True):
        logger.info("Dynamic endpoints are disabled")
        return
    
    endpoints_config = load_endpoints_config()
    endpoints = endpoints_config.get("endpoints", [])
    
    for endpoint in endpoints:
        if not endpoint.get("enabled", True):
            continue
            
        path = endpoint.get("path")
        method = endpoint.get("method", "GET").upper()
        command = endpoint.get("command")
        auth_method = endpoint.get("auth", "jwt")
        description = endpoint.get("description", "")
        
        if not path or not command:
            logger.warning(f"Skipping invalid endpoint definition: {endpoint}")
            continue
        
        # Create the endpoint handler
        async def create_endpoint_handler(request: Request, endpoint=endpoint):
            # Extract path parameters
            path_params = request.path_params
            
            # Get authentication requirements
            auth_method = endpoint.get("auth", "jwt")
            
            # Authenticate request if required
            if auth_method == "jwt":
                try:
                    token_data = await verify_token(request)
                except HTTPException:
                    return JSONResponse(
                        status_code=status.HTTP_401_UNAUTHORIZED,
                        content={"detail": "Invalid authentication credentials"}
                    )
            elif auth_method == "api_key":
                try:
                    api_key_data = await verify_api_key(request)
                except HTTPException:
                    return JSONResponse(
                        status_code=status.HTTP_401_UNAUTHORIZED,
                        content={"detail": "Invalid API key"}
                    )
            
            try:
                # Build command arguments
                args = await build_command_args(endpoint, request, path_params)
                
                # Execute command
                result = await execute_command(endpoint["command"], args)
                
                # Determine response status code
                if not result["success"]:
                    status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
                    if "not found" in result.get("error", "").lower():
                        status_code = status.HTTP_404_NOT_FOUND
                    elif any(err in result.get("error", "").lower() for err in 
                             ["invalid", "bad request", "validation"]):
                        status_code = status.HTTP_400_BAD_REQUEST
                        
                    return JSONResponse(
                        status_code=status_code,
                        content={"detail": result.get("error", "Command execution failed")}
                    )
                
                # Success response
                if request.method == "DELETE":
                    return Response(status_code=status.HTTP_204_NO_CONTENT)
                elif request.method == "POST" and "create" in args:
                    return JSONResponse(
                        status_code=status.HTTP_201_CREATED,
                        content=result.get("data", {"message": "Resource created successfully"})
                    )
                else:
                    return JSONResponse(
                        status_code=status.HTTP_200_OK,
                        content=result.get("data", result)
                    )
                
            except ValueError as e:
                return JSONResponse(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    content={"detail": str(e)}
                )
            except Exception as e:
                logger.error(f"Error handling dynamic endpoint: {str(e)}")
                return JSONResponse(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    content={"detail": f"Internal server error: {str(e)}"}
                )
        
        # Define the OpenAPI documentation for this endpoint
        endpoint_summary = description or f"{method} {path}"
        endpoint_params = []
        
        # Add documentation for parameters
        for param in endpoint.get("parameters", []):
            param_in = param.get("in", "query")
            if param_in == "path":
                continue  # Path parameters are automatically documented
                
            endpoint_params.append({
                "name": param["name"],
                "in": param_in,
                "required": param.get("required", False),
                "schema": {"type": param.get("type", "string")},
                "description": param.get("description", "")
            })
        
        # Add documentation for responses
        endpoint_responses = {}
        for status_code, response_info in endpoint.get("responses", {}).items():
            endpoint_responses[str(status_code)] = {
                "description": response_info.get("description", "")
            }
        
        # Add the endpoint to the router with the proper method
        if method == "GET":
            router.get(path, 
                      summary=endpoint_summary, 
                      description=description,
                      responses=endpoint_responses)(create_endpoint_handler)
        elif method == "POST":
            router.post(path, 
                       summary=endpoint_summary, 
                       description=description,
                       responses=endpoint_responses)(create_endpoint_handler)
        elif method == "PUT":
            router.put(path, 
                      summary=endpoint_summary, 
                      description=description,
                      responses=endpoint_responses)(create_endpoint_handler)
        elif method == "DELETE":
            router.delete(path, 
                         summary=endpoint_summary, 
                         description=description,
                         responses=endpoint_responses)(create_endpoint_handler)
        elif method == "PATCH":
            router.patch(path, 
                        summary=endpoint_summary, 
                        description=description,
                        responses=endpoint_responses)(create_endpoint_handler)
        
        logger.info(f"Registered dynamic endpoint: {method} {path}")

# Initialize dynamic endpoints when this module is imported
if config.get("dynamic_endpoints.enabled", True):
    init_dynamic_endpoints()
```

### 5. API Key Authentication (app/auth/authenticator.py)

Extend the authentication system to support API keys in addition to JWT tokens:

```python
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer, APIKeyHeader
import jwt
from typing import Dict, Optional
import os
from datetime import datetime, timedelta
import logging

from app.config.config import config

logger = logging.getLogger(__name__)

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
api_key_header = APIKeyHeader(name="X-API-Key")

# Get JWT settings from config
JWT_SECRET_KEY = config.get("auth.jwt.secret_key", "")
JWT_ALGORITHM = config.get("auth.jwt.algorithm", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = config.get("auth.jwt.token_expire_minutes", 30)

async def verify_token(request: Request) -> Dict:
    """Verify JWT token and return the payload if valid"""
    # Extract token from Authorization header
    authorization = request.headers.get("Authorization")
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authorization header is missing",
            headers={"WWW-Authenticate": "Bearer"},
        )
        
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication scheme",
                headers={"WWW-Authenticate": "Bearer"},
            )
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authorization header",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.PyJWTError as e:
        logger.error(f"Token verification failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

async def verify_api_key(request: Request) -> Dict:
    """Verify API key and return the associated data if valid"""
    # Extract API key from header
    api_key = request.headers.get("X-API-Key")
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key header is missing"
        )
    
    # Get allowed API keys from config
    api_keys = config.get("auth.api_keys", {})
    
    # Find matching client for this API key
    for client_id, key in api_keys.items():
        if key == api_key:
            return {
                "client_id": client_id,
                "scope": "api"
            }
    
    # No matching API key found
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid API key"
    )

def create_access_token(data: Dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create a new JWT token"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
    
    return encoded_jwt
```

### 6. Update Main Application (app/main.py)

Now, let's update the main application to use our new configuration system and dynamic endpoints:

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
import logging
import os

from app.config.config import config
from app.auth.authenticator import verify_token, verify_api_key
from app.routers import clusters, webhooks, dynamic
from app.services.pruning_service import setup_pruning_scheduler

# Configure logging
logging.basicConfig(
    level=logging.INFO if not config.get("server.debug") else logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="vCluster Manager API",
    description="""
    REST API for managing virtual Kubernetes clusters in EKS.
    
    This API allows you to create, manage, and destroy virtual clusters for
